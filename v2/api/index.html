


<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <title>API — Vue.js</title>
    <meta charset="utf-8">
    <meta name="description" content="Vue.js - The Progressive JavaScript Framework">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="alternate" hreflang="x-default" href="https://vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="zh" href="https://cn.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="ja" href="https://jp.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="ru" href="https://ru.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="ko" href="https://kr.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="pt-BR" href="https://br.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="fr" href="https://fr.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="es" href="https://es.vuejs.org/v2/api/index.html">

    <meta property="og:type" content="article">
    <meta property="og:title" content="API — Vue.js">
    <meta property="og:description" content="Vue.js - The Progressive JavaScript Framework">
    <meta property="og:image" content="https://vuejs.org//images/logo.png">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="API — Vue.js">
    <meta name="twitter:description" content="Vue.js - The Progressive JavaScript Framework">
    <meta name="twitter:image" content="https://vuejs.org/images/logo.png">

    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png">
    <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
    <link rel="icon" href="/images/logo.png" type="image/png">

    <meta name="msapplication-TileColor" content="#4fc08d">
    <meta name="theme-color" content="#4fc08d">

    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="manifest" href="/manifest.json">

    <link href="https://fonts.googleapis.com" rel="preconnect" crossorigin="">
    <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="">
    <link href="https://maxcdn.bootstrapcdn.com" rel="preconnect" crossorigin="">

    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono&display=swap" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Dosis:500&text=Vue.js&display=swap" rel="stylesheet" type="text/css">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    <link rel="stylesheet" href="/css/page.css">

    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="/js/vue.js"></script>

    

    <script>
      Vue.config.productionTip = false
      window.PAGE_TYPE = "api"
    </script>

    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46852172-1', 'vuejs.org');
      ga('send', 'pageview');
    </script>

    <!-- vimeo analytics -->
    <script type="text/javascript" defer="defer" src="https://extend.vimeocdn.com/ga/72160148.js"></script>
  </head>
  <body class="docs">
    <div id="mobile-bar">
      <a class="menu-button"></a>
      <a class="logo" href="/"></a>
    </div>
    <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png" alt="vue logo">
    <span>Vue.js</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input" aria-label="Search">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">Learn</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Documentation</h4></li>
    <li>
      <ul>
        <li><a href="/v2/guide/" class="nav-link">Guide</a></li>
        <li><a href="/v2/api/" class="nav-link current">API</a></li>
        <li><a href="/v2/style-guide/" class="nav-link">Style Guide</a></li>
        <li><a href="/v2/examples/" class="nav-link">Examples</a></li>
        <li><a href="/v2/cookbook/" class="nav-link">Cookbook</a></li>
      </ul>
    </li>
    <li><h4>Video Courses</h4></li>
    <li>
      <ul>
        <li>
          <a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue Mastery
          </a>
        </li>
        <li>
          <a href="https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue School
          </a>
        </li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Ecosystem</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Help</h4></li>
    <li><ul>
      <li><a href="https://forum.vuejs.org/" class="nav-link" target="_blank" rel="noopener">Forum</a></li>
      <li><a href="https://chat.vuejs.org/" class="nav-link" target="_blank" rel="noopener">Chat</a></li>
      <li><a href="https://events.vuejs.org/meetups/" class="nav-link" target="_blank" rel="noopener">Meetups</a></li>
    </ul></li>
    <li><h4>Tooling</h4></li>
    <li>
      <ul>
        <li><a href="https://github.com/vuejs/vue-devtools" class="nav-link" target="_blank" rel="noopener">Devtools</a></li>
        <li><a href="https://cli.vuejs.org/" class="nav-link" target="_blank" rel="noopener">Vue CLI</a></li>
        <li><a href="https://vue-loader.vuejs.org" class="nav-link" target="_blank" rel="noopener">Vue Loader</a></li>
      </ul>
    </li>
    <li><h4>Core Libraries</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank" rel="noopener">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank" rel="noopener">Vuex</a></li>
      <li><a href="https://ssr.vuejs.org/" class="nav-link" target="_blank" rel="noopener">Vue Server Renderer</a></li>
    </ul></li>
    <li><h4>News</h4></li>
    <li><ul>
      <li><a href="https://news.vuejs.org" class="nav-link" target="_blank" rel="noopener">Weekly News</a></li>
      <li><a href="https://github.com/vuejs/vue/projects/6" class="nav-link" target="_blank" rel="noopener">Roadmap</a></li>
      <li><a href="https://events.vuejs.org/" class="nav-link" target="_blank" rel="noopener">Events</a></li>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank" rel="noopener">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank" rel="noopener">Blog</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank" rel="noopener">Jobs</a></li>
      <li><a href="https://dev.to/t/vue" class="nav-link" target="_blank" rel="noopener">DEV Community</a></li>
    </ul></li>
  </ul>
</li>

<li>
  <a href="/v2/guide/team.html" class="nav-link team">Team</a>
</li>
<li class="nav-dropdown-container resources">
  <a href="#" class="nav-link">Resources</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/resources/partners.html" class="nav-link">Partners</a></li>
    <li><a href="/resources/themes.html" class="nav-link">Themes</a></li>
    <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank" rel="noopener">Awesome Vue</a></li>
    <li><a href="https://awesomejs.dev/for/vue/" class="nav-link" target="_blank" rel="noopener">Browse packages for Vue</a></li>
  </ul>
</li>

<!-- <li>
  <a href="/partners" class="nav-link ">Partners</a>
</li> -->
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Support Vue</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">One-time Donations</a></li>
    <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Recurring Pledges</a></li>
    <li><a href="https://vue.threadless.com" target="_blank" rel="noopener" class="nav-link">T-Shirt Shop</a></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Translations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">中文</a></li>
    <li><a href="https://jp.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">日本語</a></li>
    <li><a href="https://ru.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">Русский</a></li>
    <li><a href="https://kr.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">한국어</a></li>
    <li><a href="https://br.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">Português</a></li>
    <li><a href="https://fr.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">Français</a></li>
    <li><a href="https://vi.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">Tiếng Việt</a></li>
    <li><a href="https://es.vuejs.org/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">Español</a></li>
    <li><a href="https://docs.vuejs.id/v2/api/index.html" class="nav-link" target="_blank" rel="noopener">Bahasa Indonesia</a></li>
  </ul>
</li>


  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  

<div class="sidebar">
  <div class="sidebar-inner">
    
    <div class="list">
      <div id="sidebar-sponsors-special">
  <div class="main-sponsor">
    <span>Special Sponsor</span>
    <div>
    <a href="https://autocode.com" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/autocode.svg" alt="Autocode">
    </a>
    </div>
  </div>
</div>

<div id="sidebar-sponsors-platinum-left">
  <div class="main-sponsor">
    <span>Platinum Sponsors</span>
    <div>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/vueschool.png" alt="VueSchool">
    </a>
    <a href="https://vehikl.com/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/vehikl.png" alt="Vehikl">
    </a>
    <a href="https://retool.com/?utm_source=sponsor&utm_campaign=vue" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/retool.png" alt="Retool">
    </a>
    <a href="https://passionatepeople.io/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/passionate_people.png" alt="Passionate People">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    Become a Sponsor
  </a>
</div>



      
        <h2>
          
          API
          
            <select class="version-select">
              <option value="SELF" selected>2.x</option>
              <option value="v1">1.0</option>
              <option value="012">0.12</option>
              <option value="011">0.11</option>
            </select>
          
        </h2>
        <ul class="menu-root">
  
</ul>

      
    </div>
  </div>
</div>

<div id="sidebar-sponsors-platinum-right">
  <div class="main-sponsor">
    <span>Platinum Sponsors</span>
    <div>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/vueschool.png" alt="VueSchool">
    </a>
    <a href="https://vehikl.com/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/vehikl.png" alt="Vehikl">
    </a>
    <a href="https://retool.com/?utm_source=sponsor&utm_campaign=vue" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/retool.png" alt="Retool">
    </a>
    <a href="https://passionatepeople.io/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/passionate_people.png" alt="Passionate People">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    Become a Sponsor
  </a>
</div>




<div class="content api with-sidebar ">
  
    
      
<div id="ad">
  <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CKYIK2QU&placement=vuejsorg" id="_carbonads_js">
  </script>
</div>


    
  
  
    <h1>API</h1>
  
  
    <h2 id="Global-Config"><a href="#Global-Config" class="headerlink" title="Global Config"></a>Global Config</h2><p><code>Vue.config</code> is an object containing Vue’s global configurations. You can modify its properties listed below before bootstrapping your application:</p>
<h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h3><ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Default:</strong> <code>false</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<pre><code class="hljs js">Vue.config.silent = <span class="hljs-literal">true</span></code></pre>
<p>Suppress all Vue logs and warnings.</p>
</li>
</ul>
<h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h3><ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>Default:</strong> <code>{}</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<pre><code class="hljs js">Vue.config.optionMergeStrategies._my_option = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, child, vm</span>) </span>&#123;
  <span class="hljs-keyword">return</span> child + <span class="hljs-number">1</span>
&#125;

<span class="hljs-keyword">const</span> Profile = Vue.extend(&#123;
  <span class="hljs-attr">_my_option</span>: <span class="hljs-number">1</span>
&#125;)

<span class="hljs-comment">// Profile.options._my_option = 2</span></code></pre>
<p>Define custom merging strategies for options.</p>
<p>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/mixins.html#Custom-Option-Merge-Strategies">Custom Option Merging Strategies</a></p>
</li>
</ul>
<h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Default:</strong> <code>true</code> (<code>false</code> in production builds)</p>
</li>
<li><p><strong>Usage:</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// make sure to set this synchronously immediately after loading Vue</span>
Vue.config.devtools = <span class="hljs-literal">true</span></code></pre>
<p>Configure whether to allow <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a> inspection. This option’s default value is <code>true</code> in development builds and <code>false</code> in production builds. You can set it to <code>true</code> to enable inspection for production builds.</p>
</li>
</ul>
<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Default:</strong> <code>undefined</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<pre><code class="hljs js">Vue.config.errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) </span>&#123;
  <span class="hljs-comment">// handle error</span>
  <span class="hljs-comment">// `info` is a Vue-specific error info, e.g. which lifecycle hook</span>
  <span class="hljs-comment">// the error was found in. Only available in 2.2.0+</span>
&#125;</code></pre>
<p>Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the Vue instance.</p>
<blockquote>
<p>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is <code>undefined</code>, captured errors will be logged with <code>console.error</code> instead of crashing the app.</p>
</blockquote>
<blockquote>
<p>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</p>
</blockquote>
<blockquote>
<p>In 2.6.0+, this hook also captures errors thrown inside <code>v-on</code> DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</p>
</blockquote>
<blockquote>
<p>Error tracking services <a href="https://sentry.io/for/vue/" target="_blank" rel="noopener">Sentry</a> and <a href="https://docs.bugsnag.com/platforms/browsers/vue/" target="_blank" rel="noopener">Bugsnag</a> provide official integrations using this option.</p>
</blockquote>
</li>
</ul>
<h3 id="warnHandler"><a href="#warnHandler" class="headerlink" title="warnHandler"></a>warnHandler</h3><blockquote>
<p>New in 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Default:</strong> <code>undefined</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<pre><code class="hljs js">Vue.config.warnHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg, vm, trace</span>) </span>&#123;
  <span class="hljs-comment">// `trace` is the component hierarchy trace</span>
&#125;</code></pre>
<p>Assign a custom handler for runtime Vue warnings. Note this only works during development and is ignored in production.</p>
</li>
</ul>
<h3 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a>ignoredElements</h3><ul>
<li><p><strong>Type:</strong> <code>Array&lt;string | RegExp&gt;</code></p>
</li>
<li><p><strong>Default:</strong> <code>[]</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<pre><code class="hljs js">Vue.config.ignoredElements = [
  'my-custom-web-component',
  'another-web-component',
  // Use a `RegExp` to ignore all elements that start with "ion-"
  // 2.5+ only
  /^ion-/
]</code></pre>
<p>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an <code>Unknown custom element</code>, assuming that you forgot to register a global component or misspelled a component name.</p>
</li>
</ul>
<h3 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h3><ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>
</li>
<li><p><strong>Default:</strong> <code>{}</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<pre><code class="hljs js">Vue.config.keyCodes = &#123;
  <span class="hljs-attr">v</span>: <span class="hljs-number">86</span>,
  <span class="hljs-attr">f1</span>: <span class="hljs-number">112</span>,
  <span class="hljs-comment">// camelCase won`t work</span>
  mediaPlayPause: <span class="hljs-number">179</span>,
  <span class="hljs-comment">// instead you can use kebab-case with double quotation marks</span>
  <span class="hljs-string">"media-play-pause"</span>: <span class="hljs-number">179</span>,
  <span class="hljs-attr">up</span>: [<span class="hljs-number">38</span>, <span class="hljs-number">87</span>]
&#125;</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> @<span class="hljs-attr">keyup.media-play-pause</span>=<span class="hljs-string">"method"</span>&gt;</span></code></pre>
<p>Define custom key alias(es) for <code>v-on</code>.</p>
</li>
</ul>
<h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Default:</strong> <code>false (from 2.2.3+)</code></p>
</li>
<li><p><strong>Usage</strong>:</p>
<p>Set this to <code>true</code> to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark" target="_blank" rel="noopener">performance.mark</a> API.</p>
</li>
</ul>
<h3 id="productionTip"><a href="#productionTip" class="headerlink" title="productionTip"></a>productionTip</h3><blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Default:</strong> <code>true</code></p>
</li>
<li><p><strong>Usage</strong>:</p>
<p>Set this to <code>false</code> to prevent the production tip on Vue startup.</p>
</li>
</ul>
<h2 id="Global-API"><a href="#Global-API" class="headerlink" title="Global API"></a>Global API</h2><h3 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend( options )"></a>Vue.extend( options )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object} options</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Create a “subclass” of the base Vue constructor. The argument should be an object containing component options.</p>
<p>The special case to note here is the <code>data</code> option - it must be a function when used with <code>Vue.extend()</code>.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mount-point"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// create constructor</span>
<span class="hljs-keyword">var</span> Profile = Vue.extend(&#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,
  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Walter'</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">'White'</span>,
      <span class="hljs-attr">alias</span>: <span class="hljs-string">'Heisenberg'</span>
    &#125;
  &#125;
&#125;)
<span class="hljs-comment">// create an instance of Profile and mount it on an element</span>
<span class="hljs-keyword">new</span> Profile().$mount(<span class="hljs-string">'#mount-point'</span>)</code></pre>
<p>Will result in:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Walter White aka Heisenberg<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html">Components</a></p>
</li>
</ul>
<h3 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="Vue.nextTick( [callback, context] )"></a>Vue.nextTick( [callback, context] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
<li><code>{Object} [context]</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p>
<pre><code class="hljs js"><span class="hljs-comment">// modify data</span>
vm.msg = <span class="hljs-string">'Hello'</span>
<span class="hljs-comment">// DOM not updated yet</span>
Vue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// DOM updated</span>
&#125;)

<span class="hljs-comment">// usage as a promise (2.1.0+, see note below)</span>
Vue.nextTick()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// DOM updated</span>
  &#125;)</code></pre>
<blockquote>
<p>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don’t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</p>
</blockquote>
</li>
<li><p><strong>See also:</strong> <a href="../guide/reactivity.html#Async-Update-Queue">Async Update Queue</a></p>
</li>
</ul>
<h3 id="Vue-set-target-propertyName-index-value"><a href="#Vue-set-target-propertyName-index-value" class="headerlink" title="Vue.set( target, propertyName/index, value )"></a>Vue.set( target, propertyName/index, value )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object | Array} target</code></li>
<li><code>{string | number} propertyName/index</code></li>
<li><code>{any} value</code></li>
</ul>
</li>
<li><p><strong>Returns:</strong> the set value.</p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates. This must be used to add new properties to reactive objects, as Vue cannot detect normal property additions (e.g. <code>this.myObject.newProperty = &#39;hi&#39;</code>).</p>
<p class="tip">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/reactivity.html">Reactivity in Depth</a></p>
</li>
</ul>
<h3 id="Vue-delete-target-propertyName-index"><a href="#Vue-delete-target-propertyName-index" class="headerlink" title="Vue.delete( target, propertyName/index )"></a>Vue.delete( target, propertyName/index )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object | Array} target</code></li>
<li><code>{string | number} propertyName/index</code></li>
</ul>
<blockquote>
<p>Only in 2.2.0+: Also works with Array + index.</p>
</blockquote>
</li>
<li><p><strong>Usage:</strong></p>
<p>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</p>
<p class="tip">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/reactivity.html">Reactivity in Depth</a></p>
</li>
</ul>
<h3 id="Vue-directive-id-definition"><a href="#Vue-directive-id-definition" class="headerlink" title="Vue.directive( id, [definition] )"></a>Vue.directive( id, [definition] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Register or retrieve a global directive.</p>
<pre><code class="hljs js"><span class="hljs-comment">// register</span>
Vue.directive(<span class="hljs-string">'my-directive'</span>, &#123;
  <span class="hljs-attr">bind</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">componentUpdated</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">unbind</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;
&#125;)

<span class="hljs-comment">// register (function directive)</span>
Vue.directive(<span class="hljs-string">'my-directive'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// this will be called as `bind` and `update`</span>
&#125;)

<span class="hljs-comment">// getter, return the directive definition if registered</span>
<span class="hljs-keyword">var</span> myDirective = Vue.directive(<span class="hljs-string">'my-directive'</span>)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/custom-directive.html">Custom Directives</a></p>
</li>
</ul>
<h3 id="Vue-filter-id-definition"><a href="#Vue-filter-id-definition" class="headerlink" title="Vue.filter( id, [definition] )"></a>Vue.filter( id, [definition] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function} [definition]</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Register or retrieve a global filter.</p>
<pre><code class="hljs js"><span class="hljs-comment">// register</span>
Vue.filter(<span class="hljs-string">'my-filter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-comment">// return processed value</span>
&#125;)

<span class="hljs-comment">// getter, return the filter if registered</span>
<span class="hljs-keyword">var</span> myFilter = Vue.filter(<span class="hljs-string">'my-filter'</span>)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/filters.html">Filters</a></p>
</li>
</ul>
<h3 id="Vue-component-id-definition"><a href="#Vue-component-id-definition" class="headerlink" title="Vue.component( id, [definition] )"></a>Vue.component( id, [definition] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Register or retrieve a global component. Registration also automatically sets the component’s <code>name</code> with the given <code>id</code>.</p>
<pre><code class="hljs js"><span class="hljs-comment">// register an extended constructor</span>
Vue.component(<span class="hljs-string">'my-component'</span>, Vue.extend(&#123; <span class="hljs-comment">/* ... */</span> &#125;))

<span class="hljs-comment">// register an options object (automatically call Vue.extend)</span>
Vue.component(<span class="hljs-string">'my-component'</span>, &#123; <span class="hljs-comment">/* ... */</span> &#125;)

<span class="hljs-comment">// retrieve a registered component (always return constructor)</span>
<span class="hljs-keyword">var</span> MyComponent = Vue.component(<span class="hljs-string">'my-component'</span>)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html">Components</a></p>
</li>
</ul>
<h3 id="Vue-use-plugin"><a href="#Vue-use-plugin" class="headerlink" title="Vue.use( plugin )"></a>Vue.use( plugin )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object | Function} plugin</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</p>
<p>This method has to be called before calling <code>new Vue()</code></p>
<p>When this method is called on the same plugin multiple times, the plugin will be installed only once.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/plugins.html">Plugins</a></p>
</li>
</ul>
<h3 id="Vue-mixin-mixin"><a href="#Vue-mixin-mixin" class="headerlink" title="Vue.mixin( mixin )"></a>Vue.mixin( mixin )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object} mixin</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. <strong>Not recommended in application code</strong>.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/mixins.html#Global-Mixin">Global Mixin</a></p>
</li>
</ul>
<h3 id="Vue-compile-template"><a href="#Vue-compile-template" class="headerlink" title="Vue.compile( template )"></a>Vue.compile( template )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string} template</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Compiles a template string into a render function. <strong>Only available in the full build.</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> res = Vue.compile(<span class="hljs-string">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)

<span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123;
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello'</span>
  &#125;,
  <span class="hljs-attr">render</span>: res.render,
  <span class="hljs-attr">staticRenderFns</span>: res.staticRenderFns
&#125;)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/render-function.html">Render Functions</a></p>
</li>
</ul>
<h3 id="Vue-observable-object"><a href="#Vue-observable-object" class="headerlink" title="Vue.observable( object )"></a>Vue.observable( object )</h3><blockquote>
<p>New in 2.6.0+</p>
</blockquote>
<ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object} object</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Make an object reactive. Internally, Vue uses this on the object returned by the <code>data</code> function.</p>
<p>The returned object can be used directly inside <a href="../guide/render-function.html">render functions</a> and <a href="../guide/computed.html">computed properties</a>, and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> state = Vue.observable(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)

<span class="hljs-keyword">const</span> Demo = &#123;
  render(h) &#123;
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'button'</span>, &#123;
      <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; state.count++ &#125;&#125;
    &#125;, <span class="hljs-string">`count is: <span class="hljs-subst">$&#123;state.count&#125;</span>`</span>)
  &#125;
&#125;</code></pre>
<p class="tip">In Vue 2.x, <code>Vue.observable</code> directly mutates the object passed to it, so that it is equivalent to the object returned, as <a href="../guide/instance.html#Data-and-Methods">demonstrated here</a>. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by <code>Vue.observable</code>, rather than the object originally passed to it.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/reactivity.html">Reactivity in Depth</a></p>
</li>
</ul>
<h3 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h3><ul>
<li><p><strong>Details</strong>: Provides the installed version of Vue as a string. This is especially useful for community plugins and components, where you might use different strategies for different versions.</p>
</li>
<li><p><strong>Usage</strong>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">Number</span>(Vue.version.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>])

<span class="hljs-keyword">if</span> (version === <span class="hljs-number">2</span>) &#123;
  <span class="hljs-comment">// Vue v2.x.x</span>
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (version === <span class="hljs-number">1</span>) &#123;
  <span class="hljs-comment">// Vue v1.x.x</span>
&#125; <span class="hljs-keyword">else</span> &#123;
  <span class="hljs-comment">// Unsupported versions of Vue</span>
&#125;</code></pre>
</li>
</ul>
<h2 id="Options-Data"><a href="#Options-Data" class="headerlink" title="Options / Data"></a>Options / Data</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul>
<li><p><strong>Type:</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p>
</li>
<li><p><strong>Details:</strong></p>
<p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.</p>
<p>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</p>
<p>After the instance is created, the original data object can be accessed as <code>vm.$data</code>. The Vue instance also proxies all the properties found on the data object, so <code>vm.a</code> will be equivalent to <code>vm.$data.a</code>.</p>
<p>Properties that start with <code>_</code> or <code>$</code> will <strong>not</strong> be proxied on the Vue instance because they may conflict with Vue’s internal properties and API methods. You will have to access them as <code>vm.$data._property</code>.</p>
<p>When defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instances created! By providing a <code>data</code> function, every time a new instance is created we can call it to return a fresh copy of the initial data.</p>
<p>If required, a deep clone of the original object can be obtained by passing <code>vm.$data</code> through <code>JSON.parse(JSON.stringify(...))</code>.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;

<span class="hljs-comment">// direct instance creation</span>
<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: data
&#125;)
vm.a <span class="hljs-comment">// =&gt; 1</span>
vm.$data === data <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// must use function when in Vue.extend()</span>
<span class="hljs-keyword">var</span> Component = Vue.extend(&#123;
  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;
  &#125;
&#125;)</code></pre>
<p>Note that if you use an arrow function with the <code>data</code> property, <code>this</code> won’t be the component’s instance, but you can still access the instance as the function’s first argument:</p>
<pre><code class="hljs js">data: <span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> (&#123; <span class="hljs-attr">a</span>: vm.myProp &#125;)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/reactivity.html">Reactivity in Depth</a></p>
</li>
</ul>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ul>
<li><p><strong>Type:</strong> <code>Array&lt;string&gt; | Object</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>A list/hash of attributes that are exposed to accept data from the parent component. It has an Array-based simple syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</p>
<p>With Object-based syntax, you can use following options:</p>
<ul>
<li><code>type</code>: can be one of the following native constructors: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Array</code>, <code>Object</code>, <code>Date</code>, <code>Function</code>, <code>Symbol</code>, any custom constructor function or an array of those. Will check if a prop has a given type, and will throw a warning if it doesn’t. <a href="../guide/components-props.html#Prop-Types">More information</a> on prop types.</li>
<li><code>default</code>: <code>any</code><br>Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.</li>
<li><code>required</code>: <code>Boolean</code><br>Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.</li>
<li><code>validator</code>: <code>Function</code><br>Custom validator function that takes the prop value as the sole argument. In a non-production environment, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails). You can read more about prop validation <a href="../guide/components-props.html#Prop-Validation">here</a>.</li>
</ul>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// simple syntax</span>
Vue.component(<span class="hljs-string">'props-demo-simple'</span>, &#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'size'</span>, <span class="hljs-string">'myMessage'</span>]
&#125;)

<span class="hljs-comment">// object syntax with validation</span>
Vue.component(<span class="hljs-string">'props-demo-advanced'</span>, &#123;
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-comment">// type check</span>
    height: <span class="hljs-built_in">Number</span>,
    <span class="hljs-comment">// type check plus other validations</span>
    age: &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;
        <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">0</span>
      &#125;
    &#125;
  &#125;
&#125;)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components-props.html">Props</a></p>
</li>
</ul>
<h3 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a>propsData</h3><ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: any }</code></p>
</li>
<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>
</li>
<li><p><strong>Details:</strong></p>
<p>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> Comp = Vue.extend(&#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'msg'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span>
&#125;)

<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Comp(&#123;
  <span class="hljs-attr">propsData</span>: &#123;
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello'</span>
  &#125;
&#125;)</code></pre>
</li>
</ul>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Computed properties to be mixed into the Vue instance. All getters and setters have their <code>this</code> context automatically bound to the Vue instance.</p>
<p>Note that if you use an arrow function with a computed property, <code>this</code> won’t be the component’s instance, but you can still access the instance as the function’s first argument:</p>
<pre><code class="hljs js">computed: &#123;
  <span class="hljs-attr">aDouble</span>: <span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> vm.a * <span class="hljs-number">2</span>
&#125;</code></pre>
<p>Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance’s scope (i.e. not reactive), the computed property will <strong>not</strong> be updated.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;,
  <span class="hljs-attr">computed</span>: &#123;
    <span class="hljs-comment">// get only</span>
    aDouble: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a * <span class="hljs-number">2</span>
    &#125;,
    <span class="hljs-comment">// both get and set</span>
    aPlus: &#123;
      <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-number">1</span>
      &#125;,
      <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>&#123;
        <span class="hljs-keyword">this</span>.a = v - <span class="hljs-number">1</span>
      &#125;
    &#125;
  &#125;
&#125;)
vm.aPlus   <span class="hljs-comment">// =&gt; 2</span>
vm.aPlus = <span class="hljs-number">3</span>
vm.a       <span class="hljs-comment">// =&gt; 2</span>
vm.aDouble <span class="hljs-comment">// =&gt; 4</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/computed.html">Computed Properties</a></p>
</li>
</ul>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their <code>this</code> context automatically bound to the Vue instance.</p>
<p class="tip">Note that <strong>you should not use an arrow function to define a method</strong> (e.g. <code>plus: () =&gt; this.a++</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">plus</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">this</span>.a++
    &#125;
  &#125;
&#125;)
vm.plus()
vm.a <span class="hljs-comment">// 2</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/events.html">Event Handling</a></p>
</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: string | Function | Object | Array}</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call <code>$watch()</code> for each entry in the object at instantiation.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,
    <span class="hljs-attr">e</span>: &#123;
      <span class="hljs-attr">f</span>: &#123;
        <span class="hljs-attr">g</span>: <span class="hljs-number">5</span>
      &#125;
    &#125;
  &#125;,
  <span class="hljs-attr">watch</span>: &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'new: %s, old: %s'</span>, val, oldVal)
    &#125;,
    <span class="hljs-comment">// string method name</span>
    b: <span class="hljs-string">'someMethod'</span>,
    <span class="hljs-comment">// the callback will be called whenever any of the watched object properties change regardless of their nested depth</span>
    c: &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>
    &#125;,
    <span class="hljs-comment">// the callback will be called immediately after the start of the observation</span>
    d: &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-string">'someMethod'</span>,
      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>
    &#125;,
    <span class="hljs-comment">// you can pass array of callbacks, they will be called one-by-one</span>
    e: [
      <span class="hljs-string">'handle1'</span>,
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle2</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
      &#123;
        <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle3</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
        <span class="hljs-comment">/* ... */</span>
      &#125;
    ],
    <span class="hljs-comment">// watch vm.e.f's value: &#123;g: 5&#125;</span>
    <span class="hljs-string">'e.f'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;
  &#125;
&#125;)
vm.a = <span class="hljs-number">2</span> <span class="hljs-comment">// =&gt; new: 2, old: 1</span></code></pre>
<p class="tip">Note that <strong>you should not use an arrow function to define a watcher</strong> (e.g. <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.updateAutocomplete</code> will be undefined.</p>
</li>
<li><p><strong>See also:</strong> <a href="#vm-watch">Instance Methods / Data - vm.$watch</a></p>
</li>
</ul>
<h2 id="Options-DOM"><a href="#Options-DOM" class="headerlink" title="Options / DOM"></a>Options / DOM</h2><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><ul>
<li><p><strong>Type:</strong> <code>string | Element</code></p>
</li>
<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>
</li>
<li><p><strong>Details:</strong></p>
<p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p>
<p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p>
<p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p>
<p class="tip">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p>

<p class="tip">If neither <code>render</code> function nor <code>template</code> option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></li>
<li><a href="../guide/installation.html#Runtime-Compiler-vs-Runtime-only">Runtime + Compiler vs. Runtime-only</a></li>
</ul>
</li>
</ul>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><ul>
<li><p><strong>Type:</strong> <code>string</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>A string template to be used as the markup for the Vue instance. The template will <strong>replace</strong> the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p>
<p>If the string starts with <code>#</code> it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common <code>&lt;script type=&quot;x-template&quot;&gt;</code> trick to include templates.</p>
<p class="tip">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>

<p class="tip">If render function is present in the Vue option, the template will be ignored.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></li>
<li><a href="../guide/components.html#Content-Distribution-with-Slots">Content Distribution with Slots</a></li>
</ul>
</li>
</ul>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul>
<li><p><strong>Type:</strong> <code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a <code>createElement</code> method as it’s first argument used to create <code>VNode</code>s.</p>
<p>If the component is a functional component, the render function also receives an extra argument <code>context</code>, which provides access to contextual data since functional components are instance-less.</p>
<p class="tip">The <code>render</code> function has priority over the render function compiled from <code>template</code> option or in-DOM HTML template of the mounting element which is specified by the <code>el</code> option.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/render-function.html">Render Functions</a></p>
</li>
</ul>
<h3 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a>renderError</h3><blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p><strong>Only works in development mode.</strong></p>
<p>Provide an alternative render output when the default <code>render</code> function encounters an error. The error will be passed to <code>renderError</code> as the second argument. This is particularly useful when used together with hot-reload.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  render (h) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  &#125;,
  renderError (h, err) &#123;
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'pre'</span>, &#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> &#125;&#125;, err.stack)
  &#125;
&#125;).$mount(<span class="hljs-string">'#app'</span>)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/render-function.html">Render Functions</a></p>
</li>
</ul>
<h2 id="Options-Lifecycle-Hooks"><a href="#Options-Lifecycle-Hooks" class="headerlink" title="Options / Lifecycle Hooks"></a>Options / Lifecycle Hooks</h2><p class="tip">All lifecycle hooks automatically have their <code>this</code> context bound to the instance, so that you can access data, computed properties, and methods. This means <strong>you should not use an arrow function to define a lifecycle method</strong> (e.g. <code>created: () =&gt; this.fetchTodos()</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.fetchTodos</code> will be undefined.</p>

<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called synchronously immediately after the instance has been initialized, before data observation and event/watcher setup.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the <code>$el</code> property will not be available yet.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called right before the mounting begins: the <code>render</code> function is about to be called for the first time.</p>
<p><strong>This hook is not called during server-side rendering.</strong></p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called after the instance has been mounted, where <code>el</code> is replaced by the newly created <code>vm.$el</code>. If the root instance is mounted to an in-document element, <code>vm.$el</code> will also be in-document when <code>mounted</code> is called.</p>
<p>Note that <code>mounted</code> does <strong>not</strong> guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use <a href="#vm-nextTick">vm.$nextTick</a> inside of <code>mounted</code>:</p>
<pre><code class="hljs js">mounted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// Code that will run only after the</span>
    <span class="hljs-comment">// entire view has been rendered</span>
  &#125;)
&#125;</code></pre>
<p><strong>This hook is not called during server-side rendering.</strong></p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called when data changes, before the DOM is patched. This is a good place to access the existing DOM before an update, e.g. to remove manually added event listeners.</p>
<p><strong>This hook is not called during server-side rendering, because only the initial render is performed server-side.</strong></p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called after a data change causes the virtual DOM to be re-rendered and patched.</p>
<p>The component’s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it’s usually better to use a <a href="#computed">computed property</a> or <a href="#watch">watcher</a> instead.</p>
<p>Note that <code>updated</code> does <strong>not</strong> guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use <a href="#vm-nextTick">vm.$nextTick</a> inside of <code>updated</code>:</p>
<pre><code class="hljs js">updated: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// Code that will run only after the</span>
    <span class="hljs-comment">// entire view has been re-rendered</span>
  &#125;)
&#125;</code></pre>
<p><strong>This hook is not called during server-side rendering.</strong></p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called when a kept-alive component is activated.</p>
<p><strong>This hook is not called during server-side rendering.</strong></p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="#keep-alive">Built-in Components - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">Dynamic Components - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called when a kept-alive component is deactivated.</p>
<p><strong>This hook is not called during server-side rendering.</strong></p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="#keep-alive">Built-in Components - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">Dynamic Components - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</p>
<p><strong>This hook is not called during server-side rendering.</strong></p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><ul>
<li><p><strong>Type:</strong> <code>Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.</p>
<p><strong>This hook is not called during server-side rendering.</strong></p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h3><blockquote>
<p>New in 2.5.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Called when an error from any descendent component is captured. The hook receives three arguments: the error, the component instance that triggered the error, and a string containing information on where the error was captured. The hook can return <code>false</code> to stop the error from propagating further.</p>
<p class="tip">You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</p>

<p><strong>Error Propagation Rules</strong></p>
<ul>
<li><p>By default, all errors are still sent to the global <code>config.errorHandler</code> if it is defined, so that these errors can still be reported to an analytics service in a single place.</p>
</li>
<li><p>If multiple <code>errorCaptured</code> hooks exist on a component’s inheritance chain or parent chain, all of them will be invoked on the same error.</p>
</li>
<li><p>If the <code>errorCaptured</code> hook itself throws an error, both this error and the original captured error are sent to the global <code>config.errorHandler</code>.</p>
</li>
<li><p>An <code>errorCaptured</code> hook can return <code>false</code> to prevent the error from propagating further. This is essentially saying “this error has been handled and should be ignored.” It will prevent any additional <code>errorCaptured</code> hooks or the global <code>config.errorHandler</code> from being invoked for this error.</p>
</li>
</ul>
</li>
</ul>
<h2 id="Options-Assets"><a href="#Options-Assets" class="headerlink" title="Options / Assets"></a>Options / Assets</h2><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h3><ul>
<li><p><strong>Type:</strong> <code>Object</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>A hash of directives to be made available to the Vue instance.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/custom-directive.html">Custom Directives</a></p>
</li>
</ul>
<h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h3><ul>
<li><p><strong>Type:</strong> <code>Object</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>A hash of filters to be made available to the Vue instance.</p>
</li>
<li><p><strong>See also:</strong> <a href="#Vue-filter"><code>Vue.filter</code></a></p>
</li>
</ul>
<h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><ul>
<li><p><strong>Type:</strong> <code>Object</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>A hash of components to be made available to the Vue instance.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html">Components</a></p>
</li>
</ul>
<h2 id="Options-Composition"><a href="#Options-Composition" class="headerlink" title="Options / Composition"></a>Options / Composition</h2><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><ul>
<li><p><strong>Type:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as <code>this.$parent</code> for the child, and the child will be pushed into the parent’s <code>$children</code> array.</p>
<p class="tip">Use <code>$parent</code> and <code>$children</code> sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>

</li>
</ul>
<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><ul>
<li><p><strong>Type:</strong> <code>Array&lt;Object&gt;</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in <code>Vue.extend()</code>. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</p>
<p>Mixin hooks are called in the order they are provided, and called before the component’s own hooks.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = &#123;
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;
&#125;
<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>) &#125;,
  <span class="hljs-attr">mixins</span>: [mixin]
&#125;)
<span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-comment">// =&gt; 2</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/mixins.html">Mixins</a></p>
</li>
</ul>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ul>
<li><p><strong>Type:</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use <code>Vue.extend</code>. This is primarily intended to make it easier to extend between single file components.</p>
<p>This is similar to <code>mixins</code>.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> CompA = &#123; ... &#125;

<span class="hljs-comment">// extend CompA without having to call `Vue.extend` on either</span>
<span class="hljs-keyword">var</span> CompB = &#123;
  <span class="hljs-attr">extends</span>: CompA,
  ...
&#125;</code></pre>
</li>
</ul>
<h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h3><blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong></p>
<ul>
<li><strong>provide:</strong> <code>Object | () =&gt; Object</code></li>
<li><strong>inject:</strong> <code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li>
</ul>
</li>
<li><p><strong>Details:</strong></p>
<p class="tip"><code>provide</code> and <code>inject</code> are primarily provided for advanced plugin / component library use cases. It is NOT recommended to use them in generic application code.</p>

<p>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React’s context feature.</p>
<p>The <code>provide</code> option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support <code>Symbol</code> and <code>Reflect.ownKeys</code>.</p>
<p>The <code>inject</code> option should be either:</p>
<ul>
<li>an array of strings, or</li>
<li>an object where the keys are the local binding name and the value is either:<ul>
<li>the key (string or Symbol) to search for in available injections, or</li>
<li>an object where:<ul>
<li>the <code>from</code> property is the key (string or Symbol) to search for in available injections, and</li>
<li>the <code>default</code> property is used as fallback value</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: the <code>provide</code> and <code>inject</code> bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</p>
</blockquote>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// parent component providing 'foo'</span>
<span class="hljs-keyword">var</span> Provider = &#123;
  <span class="hljs-attr">provide</span>: &#123;
    <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>
  &#125;,
  <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-comment">// child component injecting 'foo'</span>
<span class="hljs-keyword">var</span> Child = &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'foo'</span>],
  created () &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.foo) <span class="hljs-comment">// =&gt; "bar"</span>
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;</code></pre>
<p>With ES2015 Symbols, function <code>provide</code> and object <code>inject</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-built_in">Symbol</span>()

<span class="hljs-keyword">const</span> Provider = &#123;
  provide () &#123;
    <span class="hljs-keyword">return</span> &#123;
      [s]: <span class="hljs-string">'foo'</span>
    &#125;
  &#125;
&#125;

<span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: &#123; s &#125;,
  <span class="hljs-comment">// ...</span>
&#125;</code></pre>
<blockquote>
<p>The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the <code>props</code> and the <code>data</code> initialization.</p>
</blockquote>
<p>Using an injected value as the default for a prop:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'foo'</span>],
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">bar</span>: &#123;
      <span class="hljs-keyword">default</span> () &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>Using an injected value as data entry:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'foo'</span>],
  data () &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">bar</span>: <span class="hljs-keyword">this</span>.foo
    &#125;
  &#125;
&#125;</code></pre>
<blockquote>
<p>In 2.5.0+ injections can be optional with default value:</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: &#123;
    <span class="hljs-attr">foo</span>: &#123; <span class="hljs-attr">default</span>: <span class="hljs-string">'foo'</span> &#125;
  &#125;
&#125;</code></pre>
<p>If it needs to be injected from a property with a different name, use <code>from</code> to denote the source property:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: &#123;
    <span class="hljs-attr">foo</span>: &#123;
      <span class="hljs-attr">from</span>: <span class="hljs-string">'bar'</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-string">'foo'</span>
    &#125;
  &#125;
&#125;</code></pre>
<p>Similar to prop defaults, you need to use a factory function for non primitive values:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: &#123;
    <span class="hljs-attr">foo</span>: &#123;
      <span class="hljs-attr">from</span>: <span class="hljs-string">'bar'</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
    &#125;
  &#125;
&#125;</code></pre>
</li>
</ul>
<h2 id="Options-Misc"><a href="#Options-Misc" class="headerlink" title="Options / Misc"></a>Options / Misc</h2><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><ul>
<li><p><strong>Type:</strong> <code>string</code></p>
</li>
<li><p><strong>Restriction:</strong> only respected when used as a component option.</p>
</li>
<li><p><strong>Details:</strong></p>
<p>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with <code>Vue.component()</code>, the global ID is automatically set as its name.</p>
<p>Another benefit of specifying a <code>name</code> option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a>, unnamed components will show up as <code>&lt;AnonymousComponent&gt;</code>, which isn’t very informative. By providing the <code>name</code> option, you will get a much more informative component tree.</p>
</li>
</ul>
<h3 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a>delimiters</h3><ul>
<li><p><strong>Type:</strong> <code>Array&lt;string&gt;</code></p>
</li>
<li><p><strong>Default:</strong> <code>["{{", "}}"]</code></p>
</li>
<li><p><strong>Restrictions:</strong> This option is only available in the full build, with in-browser compilation.</p>
</li>
<li><p><strong>Details:</strong></p>
<p>Change the plain text interpolation delimiters.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">delimiters</span>: [<span class="hljs-string">'$&#123;'</span>, <span class="hljs-string">'&#125;'</span>]
&#125;)

<span class="hljs-comment">// Delimiters changed to ES6 template string style</span></code></pre>
</li>
</ul>
<h3 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h3><ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Causes a component to be stateless (no <code>data</code>) and instanceless (no <code>this</code> context). They are only a <code>render</code> function that returns virtual nodes making them much cheaper to render.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/render-function.html#Functional-Components">Functional Components</a></p>
</li>
</ul>
<h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><blockquote>
<p>New in 2.2.0</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>{ prop?: string, event?: string }</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Allows a custom component to customize the prop and event used when it’s used with <code>v-model</code>. By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> prop for a different purpose. Using the <code>model</code> option can avoid the conflict in such cases.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'my-checkbox'</span>, &#123;
  <span class="hljs-attr">model</span>: &#123;
    <span class="hljs-attr">prop</span>: <span class="hljs-string">'checked'</span>,
    <span class="hljs-attr">event</span>: <span class="hljs-string">'change'</span>
  &#125;,
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-comment">// this allows using the `value` prop for a different purpose</span>
    value: <span class="hljs-built_in">String</span>,
    <span class="hljs-comment">// use `checked` as the prop which take the place of `value`</span>
    checked: &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>
    &#125;
  &#125;,
  <span class="hljs-comment">// ...</span>
&#125;)</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-checkbox</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"foo"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"some value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-checkbox</span>&gt;</span></code></pre>
<p>The above will be equivalent to:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-checkbox</span>
  <span class="hljs-attr">:checked</span>=<span class="hljs-string">"foo"</span>
  @<span class="hljs-attr">change</span>=<span class="hljs-string">"val =&gt; &#123; foo = val &#125;"</span>
  <span class="hljs-attr">value</span>=<span class="hljs-string">"some value"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">my-checkbox</span>&gt;</span></code></pre>
</li>
</ul>
<h3 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h3><blockquote>
<p>New in 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Default:</strong> <code>true</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>By default, parent scope attribute bindings that are not recognized as props will “fallthrough” and be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting <code>inheritAttrs</code> to <code>false</code>, this default behavior can be disabled. The attributes are available via the <code>$attrs</code> instance property (also new in 2.4) and can be explicitly bound to a non-root element using <code>v-bind</code>.</p>
<p>Note: this option does <strong>not</strong> affect <code>class</code> and <code>style</code> bindings.</p>
</li>
</ul>
<h3 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h3><blockquote>
<p>New in 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Default:</strong> <code>false</code></p>
</li>
<li><p><strong>Restrictions:</strong> This option is only available in the full build, with in-browser compilation.</p>
</li>
<li><p><strong>Details:</strong></p>
<p>When set to <code>true</code>, will preserve and render HTML comments found in templates. The default behavior is discarding them.</p>
</li>
</ul>
<h2 id="Instance-Properties"><a href="#Instance-Properties" class="headerlink" title="Instance Properties"></a>Instance Properties</h2><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><ul>
<li><p><strong>Type:</strong> <code>Object</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</p>
</li>
<li><p><strong>See also:</strong> <a href="#data">Options / Data - data</a></p>
</li>
</ul>
<h3 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a>vm.$props</h3><blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>Object</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>An object representing the current props a component has received. The Vue instance proxies access to the properties on its props object.</p>
</li>
</ul>
<h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h3><ul>
<li><p><strong>Type:</strong> <code>Element</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>The root DOM element that the Vue instance is managing.</p>
</li>
</ul>
<h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h3><ul>
<li><p><strong>Type:</strong> <code>Object</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">customOption</span>: <span class="hljs-string">'foo'</span>,
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$options.customOption) <span class="hljs-comment">// =&gt; 'foo'</span>
  &#125;
&#125;)</code></pre>
</li>
</ul>
<h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h3><ul>
<li><p><strong>Type:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>The parent instance, if the current instance has one.</p>
</li>
</ul>
<h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h3><ul>
<li><p><strong>Type:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</p>
</li>
</ul>
<h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h3><ul>
<li><p><strong>Type:</strong> <code>Array&lt;Vue instance&gt;</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>The direct child components of the current instance. <strong>Note there’s no order guarantee for <code>$children</code>, and it is not reactive.</strong> If you find yourself trying to use <code>$children</code> for data binding, consider using an Array and <code>v-for</code> to generate child components, and use the Array as the source of truth.</p>
</li>
</ul>
<h3 id="vm-slots"><a href="#vm-slots" class="headerlink" title="vm.$slots"></a>vm.$slots</h3><ul>
<li><p><strong>Type:</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Used to programmatically access content <a href="../guide/components.html#Content-Distribution-with-Slots">distributed by slots</a>. Each <a href="../guide/components.html#Named-Slots">named slot</a> has its own corresponding property (e.g. the contents of <code>v-slot:foo</code> will be found at <code>vm.$slots.foo</code>). The <code>default</code> property contains either nodes not included in a named slot or contents of <code>v-slot:default</code>.</p>
<p><strong>Note:</strong> <code>v-slot:foo</code> is supported in v2.6+. For older versions, you can use the <a href="../guide/components-slots.html#Deprecated-Syntax">deprecated syntax</a>.</p>
<p>Accessing <code>vm.$slots</code> is most useful when writing a component with a <a href="../guide/render-function.html">render function</a>.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>About Me<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Copyright 2016 Evan You<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>.
<span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span></code></pre>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'blog-post'</span>, &#123;
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) </span>&#123;
    <span class="hljs-keyword">var</span> header = <span class="hljs-keyword">this</span>.$slots.header
    <span class="hljs-keyword">var</span> body   = <span class="hljs-keyword">this</span>.$slots.default
    <span class="hljs-keyword">var</span> footer = <span class="hljs-keyword">this</span>.$slots.footer
    <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'div'</span>, [
      createElement(<span class="hljs-string">'header'</span>, header),
      createElement(<span class="hljs-string">'main'</span>, body),
      createElement(<span class="hljs-string">'footer'</span>, footer)
    ])
  &#125;
&#125;)</code></pre>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="#slot"><code>&lt;slot&gt;</code> Component</a></li>
<li><a href="../guide/components.html#Content-Distribution-with-Slots">Content Distribution with Slots</a></li>
<li><a href="../guide/render-function.html#Slots">Render Functions - Slots</a></li>
</ul>
</li>
</ul>
<h3 id="vm-scopedSlots"><a href="#vm-scopedSlots" class="headerlink" title="vm.$scopedSlots"></a>vm.$scopedSlots</h3><blockquote>
<p>New in 2.1.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>{ [name: string]: props =&gt; Array&lt;VNode&gt; | undefined }</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Used to programmatically access <a href="../guide/components.html#Scoped-Slots">scoped slots</a>. For each slot, including the <code>default</code> one, the object contains a corresponding function that returns VNodes.</p>
<p>Accessing <code>vm.$scopedSlots</code> is most useful when writing a component with a <a href="../guide/render-function.html">render function</a>.</p>
<p><strong>Note:</strong> since 2.6.0+, there are two notable changes to this property:</p>
<ol>
<li><p>Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return <code>undefined</code>.</p>
</li>
<li><p>All <code>$slots</code> are now also exposed on <code>$scopedSlots</code> as functions. If you work with render functions, it is now recommended to always access slots via <code>$scopedSlots</code>, whether they currently use a scope or not. This will not only make future refactors to add a scope simpler, but also ease your eventual migration to Vue 3, where all slots will be functions.</p>
</li>
</ol>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="#slot"><code>&lt;slot&gt;</code> Component</a></li>
<li><a href="../guide/components.html#Scoped-Slots">Scoped Slots</a></li>
<li><a href="../guide/render-function.html#Slots">Render Functions - Slots</a></li>
</ul>
</li>
</ul>
<h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h3><ul>
<li><p><strong>Type:</strong> <code>Object</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>An object of DOM elements and component instances, registered with <a href="#ref"><code>ref</code> attributes</a>.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/components.html#Child-Component-Refs">Child Component Refs</a></li>
<li><a href="#ref">Special Attributes - ref</a></li>
</ul>
</li>
</ul>
<h3 id="vm-isServer"><a href="#vm-isServer" class="headerlink" title="vm.$isServer"></a>vm.$isServer</h3><ul>
<li><p><strong>Type:</strong> <code>boolean</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Whether the current Vue instance is running on the server.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/ssr.html">Server-Side Rendering</a></p>
</li>
</ul>
<h3 id="vm-attrs"><a href="#vm-attrs" class="headerlink" title="vm.$attrs"></a>vm.$attrs</h3><blockquote>
<p>New in 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: string }</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Contains parent-scope attribute bindings (except for <code>class</code> and <code>style</code>) that are not recognized (and extracted) as props. When a component doesn’t have any declared props, this essentially contains all parent-scope bindings (except for <code>class</code> and <code>style</code>), and can be passed down to an inner component via <code>v-bind=&quot;$attrs&quot;</code> - useful when creating higher-order components.</p>
</li>
</ul>
<h3 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a>vm.$listeners</h3><blockquote>
<p>New in 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type:</strong> <code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p>
</li>
<li><p><strong>Read only</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Contains parent-scope <code>v-on</code> event listeners (without <code>.native</code> modifiers). This can be passed down to an inner component via <code>v-on=&quot;$listeners&quot;</code> - useful when creating transparent wrapper components.</p>
</li>
</ul>
<h2 id="Instance-Methods-Data"><a href="#Instance-Methods-Data" class="headerlink" title="Instance Methods / Data"></a>Instance Methods / Data</h2><h3 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="vm.$watch( expOrFn, callback, [options] )"></a>vm.$watch( expOrFn, callback, [options] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string | Function} expOrFn</code></li>
<li><code>{Function | Object} callback</code></li>
<li><code>{Object} [options]</code><ul>
<li><code>{boolean} deep</code></li>
<li><code>{boolean} immediate</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Returns:</strong> <code>{Function} unwatch</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</p>
</li>
</ul>
<p class="tip">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn’t keep a copy of the pre-mutate value.</p>

<ul>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// keypath</span>
vm.$watch(<span class="hljs-string">'a.b.c'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newVal, oldVal</span>) </span>&#123;
  <span class="hljs-comment">// do something</span>
&#125;)

<span class="hljs-comment">// function</span>
vm.$watch(
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// every time the expression `this.a + this.b` yields a different result,</span>
    <span class="hljs-comment">// the handler will be called. It's as if we were watching a computed</span>
    <span class="hljs-comment">// property without defining the computed property itself</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-keyword">this</span>.b
  &#125;,
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newVal, oldVal</span>) </span>&#123;
    <span class="hljs-comment">// do something</span>
  &#125;
)</code></pre>
<p><code>vm.$watch</code> returns an unwatch function that stops firing the callback:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> unwatch = vm.$watch(<span class="hljs-string">'a'</span>, cb)
<span class="hljs-comment">// later, teardown the watcher</span>
unwatch()</code></pre>
</li>
<li><p><strong>Option: deep</strong></p>
<p>To also detect nested value changes inside Objects, you need to pass in <code>deep: true</code> in the options argument. Note that you don’t need to do so to listen for Array mutations.</p>
<pre><code class="hljs js">vm.$watch(<span class="hljs-string">'someObject'</span>, callback, &#123;
  <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>
&#125;)
vm.someObject.nestedValue = <span class="hljs-number">123</span>
<span class="hljs-comment">// callback is fired</span></code></pre>
</li>
<li><p><strong>Option: immediate</strong></p>
<p>Passing in <code>immediate: true</code> in the option will trigger the callback immediately with the current value of the expression:</p>
<pre><code class="hljs js">vm.$watch(<span class="hljs-string">'a'</span>, callback, &#123;
  <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>
&#125;)
<span class="hljs-comment">// `callback` is fired immediately with current value of `a`</span></code></pre>
<p>Note that with <code>immediate</code> option you won’t be able to unwatch the given property on the first callback call.</p>
<pre><code class="hljs js"><span class="hljs-comment">// This will cause an error</span>
<span class="hljs-keyword">var</span> unwatch = vm.$watch(
  <span class="hljs-string">'value'</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    doSomething()
    unwatch()
  &#125;,
  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;
)</code></pre>
<p>If you still want to call an unwatch function inside the callback, you should check its availability first:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> unwatch = vm.$watch(
  <span class="hljs-string">'value'</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    doSomething()
    <span class="hljs-keyword">if</span> (unwatch) &#123;
      unwatch()
    &#125;
  &#125;,
  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;
)</code></pre>
</li>
</ul>
<h3 id="vm-set-target-propertyName-index-value"><a href="#vm-set-target-propertyName-index-value" class="headerlink" title="vm.$set( target, propertyName/index, value )"></a>vm.$set( target, propertyName/index, value )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object | Array} target</code></li>
<li><code>{string | number} propertyName/index</code></li>
<li><code>{any} value</code></li>
</ul>
</li>
<li><p><strong>Returns:</strong> the set value.</p>
</li>
<li><p><strong>Usage:</strong></p>
<p>This is the <strong>alias</strong> of the global <code>Vue.set</code>.</p>
</li>
<li><p><strong>See also:</strong> <a href="#Vue-set">Vue.set</a></p>
</li>
</ul>
<h3 id="vm-delete-target-propertyName-index"><a href="#vm-delete-target-propertyName-index" class="headerlink" title="vm.$delete( target, propertyName/index )"></a>vm.$delete( target, propertyName/index )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Object | Array} target</code></li>
<li><code>{string | number} propertyName/index</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>This is the <strong>alias</strong> of the global <code>Vue.delete</code>.</p>
</li>
<li><p><strong>See also:</strong> <a href="#Vue-delete">Vue.delete</a></p>
</li>
</ul>
<h2 id="Instance-Methods-Events"><a href="#Instance-Methods-Events" class="headerlink" title="Instance Methods / Events"></a>Instance Methods / Events</h2><h3 id="vm-on-event-callback"><a href="#vm-on-event-callback" class="headerlink" title="vm.$on( event, callback )"></a>vm.$on( event, callback )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string | Array&lt;string&gt;} event</code> (array only supported in 2.2.0+)</li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Listen for a custom event on the current vm. Events can be triggered by <code>vm.$emit</code>. The callback will receive all the additional arguments passed into these event-triggering methods.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js">vm.$on(<span class="hljs-string">'test'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(msg)
&#125;)
vm.$emit(<span class="hljs-string">'test'</span>, <span class="hljs-string">'hi'</span>)
<span class="hljs-comment">// =&gt; "hi"</span></code></pre>
</li>
</ul>
<h3 id="vm-once-event-callback"><a href="#vm-once-event-callback" class="headerlink" title="vm.$once( event, callback )"></a>vm.$once( event, callback )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string} event</code></li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</p>
</li>
</ul>
<h3 id="vm-off-event-callback"><a href="#vm-off-event-callback" class="headerlink" title="vm.$off( [event, callback] )"></a>vm.$off( [event, callback] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string | Array&lt;string&gt;} event</code> (array only supported in 2.2.2+)</li>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Remove custom event listener(s).</p>
<ul>
<li><p>If no arguments are provided, remove all event listeners;</p>
</li>
<li><p>If only the event is provided, remove all listeners for that event;</p>
</li>
<li><p>If both event and callback are given, remove the listener for that specific callback only.</p>
</li>
</ul>
</li>
</ul>
<h3 id="vm-emit-eventName-…args"><a href="#vm-emit-eventName-…args" class="headerlink" title="vm.$emit( eventName, […args] )"></a>vm.$emit( eventName, […args] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{string} eventName</code></li>
<li><code>[...args]</code></li>
</ul>
<p>Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function.</p>
</li>
<li><p><strong>Examples:</strong></p>
<p>Using <code>$emit</code> with only an event name:</p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'welcome-button'</span>, &#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button v-on:click="$emit('welcome')"&gt;
      Click me to be welcomed
    &lt;/button&gt;
  `</span>
&#125;)</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emit-example-simple"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-button</span> <span class="hljs-attr">v-on:welcome</span>=<span class="hljs-string">"sayHi"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#emit-example-simple'</span>,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      alert(<span class="hljs-string">'Hi!'</span>)
    &#125;
  &#125;
&#125;)</code></pre>

  <div id="emit-example-simple" class="demo">
    <welcome-button v-on:welcome="sayHi"></welcome-button>
  </div>
  <script>
    Vue.component('welcome-button', {
      template: `
        <button v-on:click="$emit('welcome')">
          Click me to be welcomed
        </button>
      `
    })
    new Vue({
      el: '#emit-example-simple',
      methods: {
        sayHi: function () {
          alert('Hi!')
        }
      }
    })
  </script>
  
<p>Using <code>$emit</code> with additional arguments:</p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'magic-eight-ball'</span>, &#123;
  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">possibleAdvice</span>: [<span class="hljs-string">'Yes'</span>, <span class="hljs-string">'No'</span>, <span class="hljs-string">'Maybe'</span>]
    &#125;
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">giveAdvice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">var</span> randomAdviceIndex = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-keyword">this</span>.possibleAdvice.length)
      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'give-advice'</span>, <span class="hljs-keyword">this</span>.possibleAdvice[randomAdviceIndex])
    &#125;
  &#125;,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button v-on:click="giveAdvice"&gt;
      Click me for advice
    &lt;/button&gt;
  `</span>
&#125;)</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emit-example-argument"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">magic-eight-ball</span> <span class="hljs-attr">v-on:give-advice</span>=<span class="hljs-string">"showAdvice"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">magic-eight-ball</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#emit-example-argument'</span>,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">showAdvice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">advice</span>) </span>&#123;
      alert(advice)
    &#125;
  &#125;
&#125;)</code></pre>

  <div id="emit-example-argument" class="demo">
    <magic-eight-ball v-on:give-advice="showAdvice"></magic-eight-ball>
  </div>
  <script>
    Vue.component('magic-eight-ball', {
      data: function () {
        return {
          possibleAdvice: ['Yes', 'No', 'Maybe']
        }
      },
      methods: {
        giveAdvice: function () {
          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)
          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])
        }
      },
      template: `
        <button v-on:click="giveAdvice">
          Click me for advice
        </button>
      `
    })
    new Vue({
      el: '#emit-example-argument',
      methods: {
        showAdvice: function (advice) {
          alert(advice)
        }
      }
    })
  </script>
  
</li>
</ul>
<h2 id="Instance-Methods-Lifecycle"><a href="#Instance-Methods-Lifecycle" class="headerlink" title="Instance Methods / Lifecycle"></a>Instance Methods / Lifecycle</h2><h3 id="vm-mount-elementOrSelector"><a href="#vm-mount-elementOrSelector" class="headerlink" title="vm.$mount( [elementOrSelector] )"></a>vm.$mount( [elementOrSelector] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Element | string} [elementOrSelector]</code></li>
<li><code>{boolean} [hydrating]</code></li>
</ul>
</li>
<li><p><strong>Returns:</strong> <code>vm</code> - the instance itself</p>
</li>
<li><p><strong>Usage:</strong></p>
<p>If a Vue instance didn’t receive the <code>el</code> option at instantiation, it will be in “unmounted” state, without an associated DOM element. <code>vm.$mount()</code> can be used to manually start the mounting of an unmounted Vue instance.</p>
<p>If <code>elementOrSelector</code> argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</p>
<p>The method returns the instance itself so you can chain other instance methods after it.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> MyComponent = Vue.extend(&#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;Hello!&lt;/div&gt;'</span>
&#125;)

<span class="hljs-comment">// create and mount to #app (will replace #app)</span>
<span class="hljs-keyword">new</span> MyComponent().$mount(<span class="hljs-string">'#app'</span>)

<span class="hljs-comment">// the above is the same as:</span>
<span class="hljs-keyword">new</span> MyComponent(&#123; <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span> &#125;)

<span class="hljs-comment">// or, render off-document and append afterwards:</span>
<span class="hljs-keyword">var</span> component = <span class="hljs-keyword">new</span> MyComponent().$mount()
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>).appendChild(component.$el)</code></pre>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></li>
<li><a href="../guide/ssr.html">Server-Side Rendering</a></li>
</ul>
</li>
</ul>
<h3 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate()"></a>vm.$forceUpdate()</h3><ul>
<li><p><strong>Usage:</strong></p>
<p>Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</p>
</li>
</ul>
<h3 id="vm-nextTick-callback"><a href="#vm-nextTick-callback" class="headerlink" title="vm.$nextTick( [callback] )"></a>vm.$nextTick( [callback] )</h3><ul>
<li><p><strong>Arguments:</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. This is the same as the global <code>Vue.nextTick</code>, except that the callback’s <code>this</code> context is automatically bound to the instance calling this method.</p>
<blockquote>
<p>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don’t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</p>
</blockquote>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-comment">// ...</span>
  methods: &#123;
    <span class="hljs-comment">// ...</span>
    example: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-comment">// modify data</span>
      <span class="hljs-keyword">this</span>.message = <span class="hljs-string">'changed'</span>
      <span class="hljs-comment">// DOM is not updated yet</span>
      <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-comment">// DOM is now updated</span>
        <span class="hljs-comment">// `this` is bound to the current instance</span>
        <span class="hljs-keyword">this</span>.doSomethingElse()
      &#125;)
    &#125;
  &#125;
&#125;)</code></pre>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="#Vue-nextTick">Vue.nextTick</a></li>
<li><a href="../guide/reactivity.html#Async-Update-Queue">Async Update Queue</a></li>
</ul>
</li>
</ul>
<h3 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy()"></a>vm.$destroy()</h3><ul>
<li><p><strong>Usage:</strong></p>
<p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.</p>
<p>Triggers the <code>beforeDestroy</code> and <code>destroyed</code> hooks.</p>
<p class="tip">In normal use cases you shouldn’t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using <code>v-if</code> and <code>v-for</code>.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p>
</li>
</ul>
<h2 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul>
<li><p><strong>Expects:</strong> <code>string</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Updates the element’s <code>textContent</code>. If you need to update the part of <code>textContent</code>, you should use <code>{{ Mustache }}</code> interpolations.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-comment">&lt;!-- same as --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/syntax.html#Text">Data Binding Syntax - Interpolations</a></p>
</li>
</ul>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul>
<li><p><strong>Expects:</strong> <code>string</code></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Updates the element’s <code>innerHTML</code>. <strong>Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates</strong>. If you find yourself trying to compose templates using <code>v-html</code>, try to rethink the solution by using components instead.</p>
<p class="tip">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS attacks</a>. Only use <code>v-html</code> on trusted content and <strong>never</strong> on user-provided content.</p>

<p class="tip">In <a href="../guide/single-file-components.html">single-file components</a>, <code>scoped</code> styles will not apply to content inside <code>v-html</code>, because that HTML is not processed by Vue’s template compiler. If you want to target <code>v-html</code> content with scoped CSS, you can instead use <a href="https://vue-loader.vuejs.org/en/features/css-modules.html" target="_blank" rel="noopener">CSS modules</a> or an additional, global <code>&lt;style&gt;</code> element with a manual scoping strategy such as BEM.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/syntax.html#Raw-HTML">Data Binding Syntax - Interpolations</a></p>
</li>
</ul>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ul>
<li><p><strong>Expects:</strong> <code>any</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Toggles the element’s <code>display</code> CSS property based on the truthy-ness of the expression value.</p>
<p>This directive triggers transitions when its condition changes.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/conditional.html#v-show">Conditional Rendering - v-show</a></p>
</li>
</ul>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul>
<li><p><strong>Expects:</strong> <code>any</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a <code>&lt;template&gt;</code> element, its content will be extracted as the conditional block.</p>
<p>This directive triggers transitions when its condition changes.</p>
<p class="tip">When used together with v-if, v-for has a higher priority than v-if. See the <a href="../guide/list.html#v-for-with-v-if">list rendering guide</a> for details.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/conditional.html">Conditional Rendering - v-if</a></p>
</li>
</ul>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ul>
<li><p><strong>Does not expect expression</strong></p>
</li>
<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Denote the “else block” for <code>v-if</code> or a <code>v-if</code>/<code>v-else-if</code> chain.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"Math.random() &gt; 0.5"</span>&gt;</span>
  Now you see me
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>
  Now you don't
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/conditional.html#v-else">Conditional Rendering - v-else</a></p>
</li>
</ul>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><blockquote>
<p>New in 2.1.0+</p>
</blockquote>
<ul>
<li><p><strong>Expects:</strong> <code>any</code></p>
</li>
<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Denote the “else if block” for <code>v-if</code>. Can be chained.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"type === 'A'"</span>&gt;</span>
  A
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'B'"</span>&gt;</span>
  B
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'C'"</span>&gt;</span>
  C
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>
  Not A/B/C
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/conditional.html#v-else-if">Conditional Rendering - v-else-if</a></p>
</li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li><p><strong>Expects:</strong> <code>Array | Object | number | string | Iterable (since 2.6)</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Render the element or template block multiple times based on the source data. The directive’s value must use the special syntax <code>alias in expression</code> to provide an alias for the current element being iterated on:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span>&gt;</span>
  &#123;&#123; item.text &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(val, key) in object"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(val, name, index) in object"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The default behavior of <code>v-for</code> will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the <code>key</code> special attribute:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>
  &#123;&#123; item.text &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>In 2.6+, <code>v-for</code> can also work on values that implement the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" target="_blank" rel="noopener">Iterable Protocol</a>, including native <code>Map</code> and <code>Set</code>. However, it should be noted that Vue 2.x currently does not support reactivity on <code>Map</code> and <code>Set</code> values, so cannot automatically detect changes.</p>
<p class="tip">When used together with v-if, v-for has a higher priority than v-if. See the <a href="../guide/list.html#v-for-with-v-if">list rendering guide</a> for details.</p>

<p>The detailed usage for <code>v-for</code> is explained in the guide section linked below.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/list.html">List Rendering</a></li>
<li><a href="../guide/list.html#key">key</a></li>
</ul>
</li>
</ul>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li><p><strong>Shorthand:</strong> <code>@</code></p>
</li>
<li><p><strong>Expects:</strong> <code>Function | Inline Statement | Object</code></p>
</li>
<li><p><strong>Argument:</strong> <code>event</code></p>
</li>
<li><p><strong>Modifiers:</strong></p>
<ul>
<li><code>.stop</code> - call <code>event.stopPropagation()</code>.</li>
<li><code>.prevent</code> - call <code>event.preventDefault()</code>.</li>
<li><code>.capture</code> - add event listener in capture mode.</li>
<li><code>.self</code> - only trigger handler if event was dispatched from this element.</li>
<li><code>.{keyCode | keyAlias}</code> - only trigger handler on certain keys.</li>
<li><code>.native</code> - listen for a native event on the root element of component.</li>
<li><code>.once</code> - trigger handler at most once.</li>
<li><code>.left</code> - (2.2.0+) only trigger handler for left button mouse events.</li>
<li><code>.right</code> - (2.2.0+) only trigger handler for right button mouse events.</li>
<li><code>.middle</code> - (2.2.0+) only trigger handler for middle button mouse events.</li>
<li><code>.passive</code> - (2.3.0+) attaches a DOM event with <code>{ passive: true }</code>.</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Attaches an event listener to the element. The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.</p>
<p>When used on a normal element, it listens to <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener"><strong>native DOM events</strong></a> only. When used on a custom element component, it listens to <strong>custom events</strong> emitted on that child component.</p>
<p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>.</p>
<p>Starting in 2.4.0+, <code>v-on</code> also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- method handler --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- dynamic event (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:</span>[<span class="hljs-attr">event</span>]=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- inline statement --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"doThat('hello', $event)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- shorthand --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- shorthand dynamic event (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- stop propagation --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- prevent default --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- prevent default without expression --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-comment">&lt;!-- chain modifiers --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- key modifier using keyAlias --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">"onEnter"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- key modifier using keyCode --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.13</span>=<span class="hljs-string">"onEnter"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- the click event will be triggered at most once --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.once</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- object syntax (2.4.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"&#123; mousedown: doThis, mouseup: doThat &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>Listening to custom events on a child component (the handler is called when “my-event” is emitted on the child):</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> @<span class="hljs-attr">my-event</span>=<span class="hljs-string">"handleThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- inline statement --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> @<span class="hljs-attr">my-event</span>=<span class="hljs-string">"handleThis(123, $event)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- native event on component --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"onClick"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/events.html">Event Handling</a></li>
<li><a href="../guide/components.html#Custom-Events">Components - Custom Events</a></li>
</ul>
</li>
</ul>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul>
<li><p><strong>Shorthand:</strong> <code>:</code></p>
</li>
<li><p><strong>Expects:</strong> <code>any (with argument) | Object (without argument)</code></p>
</li>
<li><p><strong>Argument:</strong> <code>attrOrProp (optional)</code></p>
</li>
<li><p><strong>Modifiers:</strong></p>
<ul>
<li><code>.prop</code> - Bind as a DOM property instead of an attribute (<a href="https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028" target="_blank" rel="noopener">what’s the difference?</a>). If the tag is a component then <code>.prop</code> will set the property on the component’s <code>$el</code>.</li>
<li><code>.camel</code> - (2.1.0+) transform the kebab-case attribute name into camelCase.</li>
<li><code>.sync</code> - (2.3.0+) a syntax sugar that expands into a <code>v-on</code> handler for updating the bound value.</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Dynamically bind one or more attributes, or a component prop to an expression.</p>
<p>When used to bind the <code>class</code> or <code>style</code> attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</p>
<p>When used for prop binding, the prop must be properly declared in the child component.</p>
<p>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode <code>class</code> and <code>style</code> does not support Array or Objects.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- bind an attribute --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">"imageSrc"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- dynamic attribute name (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">"value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- shorthand --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"imageSrc"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- shorthand dynamic attribute name (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">"value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- with inline string concatenation --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"'/path/to/images/' + fileName"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- class binding --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"[classA, classB]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- style binding --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- binding an object of attributes --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"&#123; id: someProp, 'other-attr': otherProp &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- DOM attribute binding with prop modifier --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:text-content.prop</span>=<span class="hljs-string">"text"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- prop binding. "prop" must be declared in my-component. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">:prop</span>=<span class="hljs-string">"someThing"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- pass down parent props in common with a child component --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$props"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- XLink --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:xlink:special</span>=<span class="hljs-string">"foo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">:view-box.camel</span>=<span class="hljs-string">"viewBox"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p><code>.camel</code> is not needed if you are using string templates, or compiling with <code>vue-loader</code>/<code>vueify</code>.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/class-and-style.html">Class and Style Bindings</a></li>
<li><a href="../guide/components.html#Props">Components - Props</a></li>
<li><a href="../guide/components.html#sync-Modifier">Components - <code>.sync</code> Modifier</a></li>
</ul>
</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li><p><strong>Expects:</strong> varies based on value of form inputs element or output of components</p>
</li>
<li><p><strong>Limited to:</strong></p>
<ul>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
<li>components</li>
</ul>
</li>
<li><p><strong>Modifiers:</strong></p>
<ul>
<li><a href="../guide/forms.html#lazy"><code>.lazy</code></a> - listen to <code>change</code> events instead of <code>input</code></li>
<li><a href="../guide/forms.html#number"><code>.number</code></a> - cast valid input string to numbers</li>
<li><a href="../guide/forms.html#trim"><code>.trim</code></a> - trim input</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/forms.html">Form Input Bindings</a></li>
<li><a href="../guide/components.html#Form-Input-Components-using-Custom-Events">Components - Form Input Components using Custom Events</a></li>
</ul>
</li>
</ul>
<h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><ul>
<li><p><strong>Shorthand:</strong> <code>#</code></p>
</li>
<li><p><strong>Expects:</strong> JavaScript expression that is valid in a function argument position (supports destructuring in <a href="../guide/components-slots.html#Slot-Props-Destructuring">supported environments</a>). Optional - only needed if expecting props to be passed to the slot.</p>
</li>
<li><p><strong>Argument:</strong> slot name (optional, defaults to <code>default</code>)</p>
</li>
<li><p><strong>Limited to:</strong></p>
<ul>
<li><code>&lt;template&gt;</code></li>
<li><a href="../guide/components-slots.html#Abbreviated-Syntax-for-Lone-Default-Slots">components</a> (for a lone default slot with props)</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>Denote named slots or slots that expect to receive props.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Named slots --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    Header content
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  Default slot content

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    Footer content
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Named slot that receives props --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">infinite-scroll</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:item</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>
      &#123;&#123; slotProps.item.text &#125;&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">infinite-scroll</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Default slot that receive props, with destructuring --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mouse-position</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"&#123; x, y &#125;"</span>&gt;</span>
  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">mouse-position</span>&gt;</span></code></pre>
<p>For more details, see the links below.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/components-slots.html">Components - Slots</a></li>
<li><a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md" target="_blank" rel="noopener">RFC-0001</a></li>
</ul>
</li>
</ul>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul>
<li><p><strong>Does not expect expression</strong></p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
</li>
</ul>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul>
<li><p><strong>Does not expect expression</strong></p>
</li>
<li><p><strong>Usage:</strong></p>
<p>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</p>
</li>
<li><p><strong>Example:</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span> &#123;
  <span class="hljs-attribute">display</span>: none;
&#125;</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-cloak</span>&gt;</span>
  &#123;&#123; message &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p>
</li>
</ul>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul>
<li><p><strong>Does not expect expression</strong></p>
</li>
<li><p><strong>Details:</strong></p>
<p>Render the element and component <strong>once</strong> only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- single element --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-comment">&lt;!-- the element have children --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-once</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>comment<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-comment">&lt;!-- component --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-once</span> <span class="hljs-attr">:comment</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>
<span class="hljs-comment">&lt;!-- `v-for` directive --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"i in list"</span> <span class="hljs-attr">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/syntax.html#Text">Data Binding Syntax - interpolations</a></li>
<li><a href="../guide/components.html#Cheap-Static-Components-with-v-once">Components - Cheap Static Components with <code>v-once</code></a></li>
</ul>
</li>
</ul>
<h2 id="Special-Attributes"><a href="#Special-Attributes" class="headerlink" title="Special Attributes"></a>Special Attributes</h2><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><ul>
<li><p><strong>Expects:</strong> <code>number | string</code></p>
<p>The <code>key</code> special attribute is primarily used as a hint for Vue’s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</p>
<p>Children of the same common parent must have <strong>unique keys</strong>. Duplicate keys will cause render errors.</p>
<p>The most common use case is combined with <code>v-for</code>:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<p>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</p>
<ul>
<li>Properly trigger lifecycle hooks of a component</li>
<li>Trigger transitions</li>
</ul>
<p>For example:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></code></pre>
<p>When <code>text</code> changes, the <code>&lt;span&gt;</code> will always be replaced instead of patched, so a transition will be triggered.</p>
</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li><p><strong>Expects:</strong> <code>string</code></p>
<p><code>ref</code> is used to register a reference to an element or a child component. The reference will be registered under the parent component’s <code>$refs</code> object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- vm.$refs.p will be the DOM node --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"p"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-comment">&lt;!-- vm.$refs.child will be the child component instance --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"child"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span></code></pre>
<p>When used on elements/components with <code>v-for</code>, the registered reference will be an Array containing DOM nodes or component instances.</p>
<p>An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don’t exist yet! <code>$refs</code> is also non-reactive, therefore you should not attempt to use it in templates for data-binding.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html#Child-Component-Refs">Child Component Refs</a></p>
</li>
</ul>
<h3 id="is"><a href="#is" class="headerlink" title="is"></a>is</h3><ul>
<li><p><strong>Expects:</strong> <code>string | Object (component’s options object)</code></p>
<p>Used for <a href="../guide/components.html#Dynamic-Components">dynamic components</a> and to work around <a href="../guide/components.html#DOM-Template-Parsing-Caveats">limitations of in-DOM templates</a>.</p>
<p>For example:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- component changes when currentView changes --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"currentView"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- necessary because `&lt;my-row&gt;` would be invalid inside --&gt;</span>
<span class="hljs-comment">&lt;!-- a `&lt;table&gt;` element and so would be hoisted out      --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">is</span>=<span class="hljs-string">"my-row"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre>
<p>For detailed usage, follow the links in the description above.</p>
</li>
<li><p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/components.html#Dynamic-Components">Dynamic Components</a></li>
<li><a href="../guide/components.html#DOM-Template-Parsing-Caveats">DOM Template Parsing Caveats</a></li>
</ul>
</li>
</ul>
<h3 id="slot-deprecated"><a href="#slot-deprecated" class="headerlink" title="slot deprecated"></a>slot <sup style="color:#c92222">deprecated</sup></h3><p><strong>Prefer <a href="#v-slot">v-slot</a> in 2.6.0+.</strong></p>
<ul>
<li><p><strong>Expects:</strong> <code>string</code></p>
<p>Used on content inserted into child components to indicate which named slot the content belongs to.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html#Named-Slots-with-slot">Named Slots with <code>slot</code></a></p>
</li>
</ul>
<h3 id="slot-scope-deprecated"><a href="#slot-scope-deprecated" class="headerlink" title="slot-scope deprecated"></a>slot-scope <sup style="color:#c92222">deprecated</sup></h3><p><strong>Prefer <a href="#v-slot">v-slot</a> in 2.6.0+.</strong></p>
<ul>
<li><p><strong>Expects:</strong> <code>function argument expression</code></p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Used to denote an element or component as a scoped slot. The attribute’s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for <a href="#scope-replaced"><code>scope</code></a> in 2.5.0+.</p>
<p>This attribute does not support dynamic binding.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html#Scoped-Slots-with-slot-scope">Scoped Slots with <code>slot-scope</code></a></p>
</li>
</ul>
<h3 id="scope-removed"><a href="#scope-removed" class="headerlink" title="scope removed"></a>scope <sup style="color:#c92222">removed</sup></h3><p><strong>Replaced by <a href="#slot-scope">slot-scope</a> in 2.5.0+. Prefer <a href="#v-slot">v-slot</a> in 2.6.0+.</strong></p>
<p>Used to denote a <code>&lt;template&gt;</code> element as a scoped slot.</p>
<ul>
<li><p><strong>Usage:</strong></p>
<p>Same as <a href="#slot-scope"><code>slot-scope</code></a> except that <code>scope</code> can only be used on <code>&lt;template&gt;</code> elements.</p>
</li>
</ul>
<h2 id="Built-In-Components"><a href="#Built-In-Components" class="headerlink" title="Built-In Components"></a>Built-In Components</h2><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>
<li><code>inline-template</code> - boolean</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>A “meta component” for rendering dynamic components. The actual component to render is determined by the <code>is</code> prop:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- a dynamic component controlled by --&gt;</span>
<span class="hljs-comment">&lt;!-- the `componentId` property on the vm --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"componentId"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- can also render registered component or component passed as prop --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"$options.components.child"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html#Dynamic-Components">Dynamic Components</a></p>
</li>
</ul>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>name</code> - string, Used to automatically generate transition CSS class names. e.g. <code>name: &#39;fade&#39;</code> will auto expand to <code>.fade-enter</code>, <code>.fade-enter-active</code>, etc. Defaults to <code>&quot;v&quot;</code>.</li>
<li><code>appear</code> - boolean, Whether to apply transition on initial render. Defaults to <code>false</code>.</li>
<li><code>css</code> - boolean, Whether to apply CSS transition classes. Defaults to <code>true</code>. If set to <code>false</code>, will only trigger JavaScript hooks registered via component events.</li>
<li><code>type</code> - string, Specifies the type of transition events to wait for to determine transition end timing. Available values are <code>&quot;transition&quot;</code> and <code>&quot;animation&quot;</code>. By default, it will automatically detect the type that has a longer duration.</li>
<li><code>mode</code> - string, Controls the timing sequence of leaving/entering transitions. Available modes are <code>&quot;out-in&quot;</code> and <code>&quot;in-out&quot;</code>; defaults to simultaneous.</li>
<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number }, Specifies the duration of transition. By default, Vue waits for the first <code>transitionend</code> or <code>animationend</code> event on the root transition element.</li>
<li><code>enter-class</code> - string</li>
<li><code>leave-class</code> - string</li>
<li><code>appear-class</code> - string</li>
<li><code>enter-to-class</code> - string</li>
<li><code>leave-to-class</code> - string</li>
<li><code>appear-to-class</code> - string</li>
<li><code>enter-active-class</code> - string</li>
<li><code>leave-active-class</code> - string</li>
<li><code>appear-active-class</code> - string</li>
</ul>
</li>
<li><p><strong>Events:</strong></p>
<ul>
<li><code>before-enter</code></li>
<li><code>before-leave</code></li>
<li><code>before-appear</code></li>
<li><code>enter</code></li>
<li><code>leave</code></li>
<li><code>appear</code></li>
<li><code>after-enter</code></li>
<li><code>after-leave</code></li>
<li><code>after-appear</code></li>
<li><code>enter-cancelled</code></li>
<li><code>leave-cancelled</code> (<code>v-show</code> only)</li>
<li><code>appear-cancelled</code></li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p><code>&lt;transition&gt;</code> serve as transition effects for <strong>single</strong> element/component. The <code>&lt;transition&gt;</code> only applies the transition behavior to the wrapped content inside; it doesn’t render an extra DOM element, or show up in the inspected component hierarchy.</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- simple element --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ok"</span>&gt;</span>toggled content<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>

<span class="hljs-comment">&lt;!-- dynamic component --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fade"</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"out-in"</span> <span class="hljs-attr">appear</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>

<span class="hljs-comment">&lt;!-- event hooking --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transition-demo"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> @<span class="hljs-attr">after-enter</span>=<span class="hljs-string">"transitionComplete"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"ok"</span>&gt;</span>toggled content<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  ...
  methods: &#123;
    <span class="hljs-attr">transitionComplete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;
      <span class="hljs-comment">// for passed 'el' that DOM element as the argument, something ...</span>
    &#125;
  &#125;
  ...
&#125;).$mount(<span class="hljs-string">'#transition-demo'</span>)</code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/transitions.html">Transitions: Entering, Leaving, and Lists</a></p>
</li>
</ul>
<h3 id="transition-group"><a href="#transition-group" class="headerlink" title="transition-group"></a>transition-group</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>tag</code> - string, defaults to <code>span</code>.</li>
<li><code>move-class</code> - overwrite CSS class applied during moving transition.</li>
<li>exposes the same props as <code>&lt;transition&gt;</code> except <code>mode</code>.</li>
</ul>
</li>
<li><p><strong>Events:</strong></p>
<ul>
<li>exposes the same events as <code>&lt;transition&gt;</code>.</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p><code>&lt;transition-group&gt;</code> serve as transition effects for <strong>multiple</strong> elements/components. The <code>&lt;transition-group&gt;</code> renders a real DOM element. By default it renders a <code>&lt;span&gt;</code>, and you can configure what element it should render via the <code>tag</code> attribute.</p>
<p>Note every child in a <code>&lt;transition-group&gt;</code> must be <strong>uniquely keyed</strong> for the animations to work properly.</p>
<p><code>&lt;transition-group&gt;</code> supports moving transitions via CSS transform. When a child’s position on screen has changed after an update, it will get applied a moving CSS class (auto generated from the <code>name</code> attribute or configured with the <code>move-class</code> attribute). If the CSS <code>transform</code> property is “transition-able” when the moving class is applied, the element will be smoothly animated to its destination using the <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="noopener">FLIP technique</a>.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">"ul"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"slide"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>
    &#123;&#123; item.text &#125;&#125;
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span></code></pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/transitions.html">Transitions: Entering, Leaving, and Lists</a></p>
</li>
</ul>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>include</code> - string or RegExp or Array. Only components with matching names will be cached.</li>
<li><code>exclude</code> - string or RegExp or Array. Any component with a matching name will not be cached.</li>
<li><code>max</code> - number. The maximum number of component instances to cache.</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p>When wrapped around a dynamic component, <code>&lt;keep-alive&gt;</code> caches the inactive component instances without destroying them. Similar to <code>&lt;transition&gt;</code>, <code>&lt;keep-alive&gt;</code> is an abstract component: it doesn’t render a DOM element itself, and doesn’t show up in the component parent chain.</p>
<p>When a component is toggled inside <code>&lt;keep-alive&gt;</code>, its <code>activated</code> and <code>deactivated</code> lifecycle hooks will be invoked accordingly.</p>
<blockquote>
<p>In 2.2.0+ and above, <code>activated</code> and <code>deactivated</code> will fire for all nested components inside a <code>&lt;keep-alive&gt;</code> tree.</p>
</blockquote>
<p>Primarily used to preserve component state or avoid re-rendering.</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- basic --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- multiple conditional children --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">comp-a</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"a &gt; 1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp-a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">comp-b</span> <span class="hljs-attr">v-else</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp-b</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- used together with `&lt;transition&gt;` --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></code></pre>
<p>Note, <code>&lt;keep-alive&gt;</code> is designed for the case where it has one direct child component that is being toggled. It does not work if you have <code>v-for</code> inside it. When there are multiple conditional children, as above, <code>&lt;keep-alive&gt;</code> requires that only one child is rendered at a time.</p>
</li>
<li><p><strong><code>include</code> and <code>exclude</code></strong></p>
<blockquote>
<p>New in 2.1.0+</p>
</blockquote>
<p>The <code>include</code> and <code>exclude</code> props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- comma-delimited string --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">"a,b"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- regex (use `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"/a|b/"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Array (use `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"['a', 'b']"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></code></pre>
<p>The match is first checked on the component’s own <code>name</code> option, then its local registration name (the key in the parent’s <code>components</code> option) if the <code>name</code> option is not available. Anonymous components cannot be matched against.</p>
</li>
<li><p><strong><code>max</code></strong></p>
<blockquote>
<p>New in 2.5.0+</p>
</blockquote>
<p>The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">"10"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></code></pre>
<p class="tip"><code>&lt;keep-alive&gt;</code> does not work with functional components because they do not have instances to be cached.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html#keep-alive">Dynamic Components - keep-alive</a></p>
</li>
</ul>
<h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>name</code> - string, Used for named slot.</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p><code>&lt;slot&gt;</code> serve as content distribution outlets in component templates. <code>&lt;slot&gt;</code> itself will be replaced.</p>
<p>For detailed usage, see the guide section linked below.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/components.html#Content-Distribution-with-Slots">Content Distribution with Slots</a></p>
</li>
</ul>
<h2 id="VNode-Interface"><a href="#VNode-Interface" class="headerlink" title="VNode Interface"></a>VNode Interface</h2><ul>
<li>Please refer to the <a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js" target="_blank" rel="noopener">VNode class declaration</a>.</li>
</ul>
<h2 id="Server-Side-Rendering"><a href="#Server-Side-Rendering" class="headerlink" title="Server-Side Rendering"></a>Server-Side Rendering</h2><ul>
<li>Please refer to the <a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer" target="_blank" rel="noopener">vue-server-renderer package documentation</a>.</li>
</ul>

  
  
  <div class="footer">
      <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div id="bsa-native"></div>
<script>
_bsa.init('custom', 'CKYD62QM', 'placement:vuejsorg',
  {
    target: '#bsa-native',
    template: '<a class="native-box" href="##statlink##"><div class="native-sponsor">Sponsor</div><div class="native-text"><strong>##company##</strong> — ##description##</div></a>'
  }
);
</script>


    Caught a mistake or want to contribute to the documentation?
    <a href="https://github.com/vuejs/vuejs.org/blob/master/src/v2/api/index.md" rel="noopener" target="_blank">
      Edit this page on GitHub!
    </a>
  </div>
</div>

      </div>
      <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/css.escape.js"></script>
    <script src="/js/common.js"></script>

    <!-- search -->
    <link href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/search.css">
    <script src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <script>
    [
      '#search-query-nav',
      '#search-query-sidebar',
      '#search-query-menu'
    ].forEach(function (selector) {
      if (!document.querySelector(selector)) return
      // search index defaults to v2
      var match = window.location.pathname.match(/^\/(v\d+)/)
      var version = match ? match[1] : 'v2'
      docsearch({
      appId: 'BH4D9OD16A',
      apiKey: '85cc3221c9f23bfbaa4e3913dd7625ea',
      indexName: 'vuejs',
      inputSelector: selector,
      algoliaOptions: { facetFilters: ["version:" + version] },
      autocompleteOptions: { hint: false, appendTo: 'body'}
      })
    })
    </script>
  </body>
</html>
